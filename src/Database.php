<?php declare(strict_types=1);

namespace Frodo;

use Frodo\Database\SQLite;
use Frodo\Encoder;
use Frodo\Exception\DatabaseException;
use Frodo\Exception\NotFoundException;
use Frodo\Exception\InUseException;
use \Monolog\Logger;
use \Monolog\Registry;

class Database
{

    /**
     * Some notes on the db schema
     *
     * What is going on with the `is_autogen` nullable field?
     * Our url shorten has a few constraints.
     * 1) A given long url should always return the same generated short url
     * 2) Users should be able to create custom short urls
     * Given that I'm using the autoincrement id to produce short urls,
     * I cannot use the shorturl to dedupe.
     *
     * Simply doing a read to check for the long url, then writing
     * if not found would create a race condition. This is true
     * even if the read-write is done within a db transaction.
     * In order to guarantee uniqueness, I need a db constraint.
     * I can't just put the unique constraint on the long_url though
     * because this would preclude custom short urls.
     *
     * In sqlite (and mysql, but not all sql servers), nulls do not count
     * towards uniqueness constraints. I can therefore use an additional
     * field `is_autogen` as part of the unique index. `is_autogen` will be
     * 1 for autogenerated short urls, and null for custom.
     *
     * In a production system, I would not index the full
     * long_url - it would be too slow and space inefficient.
     * Other dbs allow indexing a prefix of a long varchar field, or I
     * could store a hash of the long url and index that.
     *
     * visit_log table:
     * In a production system, visits should not be written to the same database
     * that's serving prod traffic, but to some event queue that sinks
     * to an OLAP database. Summary stats from OLAP tables could be
     * published back to the prod db at regular intervals to power
     * the stats page.
     */
    private const INIT_SQL = [
        "CREATE TABLE IF NOT EXISTS `urls` (
            `id` INTEGER PRIMARY KEY AUTOINCREMENT,
            `long_url` text NOT NULL,
            `short_url` text NOT NULL DEFAULT '',
            `is_autogen` unsigned integer DEFAULT NULL,
            `create_date` unsigned integer NOT NULL
        );",
        'CREATE UNIQUE INDEX IF NOT EXISTS `short_url_idx` ON `urls`(`short_url`);',
        'CREATE UNIQUE INDEX IF NOT EXISTS `long_url_autogen_idx` ON `urls`(`long_url`, `is_autogen`);',
        "CREATE TABLE IF NOT EXISTS `visit_log` (
            `id` INTEGER PRIMARY KEY,
            `url_id` integer NOT NULL,
            `create_date` unsigned integer NOT NULL
        );",
        'CREATE INDEX IF NOT EXISTS `url_id_date_idx` ON `visit_log`(`url_id`, `create_date`);',
    ];

    /** @var SQLite */
    private $sqlite;

    /** @var Encoder */
    private $encoder;

    /** @var Logger */
    private $logger;

    public function __construct(string $datafile, Encoder $encoder, Logger $logger = null)
    {
        $this->encoder = $encoder;
        $this->sqlite  = new SQLite($datafile);

        // Initialize the database
        $this->sqlite->runInTransaction(
            [$this->sqlite, 'executeMultiNoParams'],
            [self::INIT_SQL]
        );

        if (is_null($logger)) {
            $logger = Registry::logger();
        }
        $this->logger = $logger;
    }

    /** @throws \Exception */
    public function findOrCreateAutoShortUrl(string $long_url): string
    {

        try {
            $short_url = $this->sqlite->runInTransaction(
                function (string $long_url): string {
                    // Attempt to store new url record
                    $this->sqlite->executeSingle(
                        "INSERT INTO `urls` (`long_url`, `is_autogen`, `create_date`) VALUES (?, 1, strftime('%s', 'now'));",
                        [[$long_url, \SQLITE3_TEXT]]
                    );

                    // Get the last autogenerated id on this connection
                    $row_id = $this->sqlite->lastInsertRowID();

                    // Store encoded short_url
                    // Choosing to do some extra work on the write side
                    // to make the read code simpler
                    // assuming a url shortener will be
                    // a read-heavy application
                    $short_url = $this->encoder->encode($row_id);
                    $this->sqlite->executeSingle(
                        "UPDATE `urls` SET `short_url`=? WHERE `id`=?;",
                        [
                            [$short_url, \SQLITE3_TEXT],
                            [$row_id, \SQLITE3_INTEGER],
                        ]
                    );

                    return $short_url;
                },
                [$long_url]
            );
            '@phan-var string $short_url';
        } catch (DatabaseException $e) {
            // duplicate key exception:
            // lookup the existing short_url
            if ($e->getDbErrorCode() === SQLite::SQLITE_CONSTRAINT) {
                $res = $this->sqlite->executeSingle(
                    "SELECT `short_url` FROM `urls` WHERE `long_url`=? AND `is_autogen`=1;",
                    [[$long_url, \SQLITE3_TEXT]]
                );
                $short_url = $res[0]['short_url'] ?? null;
                if (is_null($short_url)) {
                    $this->logger->error("Unexpected exception retrieving short url for long url {$long_url} after duplicate key exception");
                    throw new \RuntimeException("Unexpected exception retrieving short url");
                }
                return $short_url;
            }

            throw $e;
        }

        return $short_url;
    }

    public function createCustomShortUrl(string $long_url, string $short_url): string
    {
        try {
            $this->sqlite->executeSingle(
                "INSERT INTO `urls` (`long_url`, `short_url`, `create_date`) VALUES (?, ?, strftime('%s', 'now'));",
                [
                    [$long_url, \SQLITE3_TEXT],
                    [$short_url, \SQLITE3_TEXT],
                ]
            );
        } catch (DatabaseException $e) {
            if ($e->getDbErrorCode() === SQLite::SQLITE_CONSTRAINT) {
                throw new InUseException();
            }
            throw $e;
        }

        return $short_url;
    }

    public function findByShortUrl(string $short_url): array
    {
        $res = $this->sqlite->executeSingle(
            "SELECT * FROM `urls` WHERE `short_url`=?",
            [[$short_url, \SQLITE3_TEXT]]
        );

        $long_url = $res[0]['long_url'] ?? null;
        if (is_null($long_url)) {
            throw new NotFoundException();
        }

        return $res[0];
    }

    public function findByShortUrlAndUpdateVisitLog(string $short_url): array
    {
        $url = $this->findByShortUrl($short_url);
        try {
            $this->sqlite->executeSingle(
                "INSERT INTO `visit_log` (`url_id`, `create_date`) VALUES (?, strftime('%s', 'now'));",
                [[$url['id'], \SQLITE3_INTEGER]]
            );
        } catch (\Exception $e) {
            // ignore
        }

        return $url;
    }

    public function getVisitsPerDayForUrl(int $url_id): array
    {

        $res = $this->sqlite->executeSingle(
            "WITH `by_day` as (SELECT `url_id`, date(`create_date`, 'unixepoch', 'localtime') as `day` from `visit_log`) SELECT `day`, count(*) as count FROM `by_day` WHERE `url_id`=? group by url_id, day;",
            [[$url_id, \SQLITE3_INTEGER]]
        );

        $hits_per_day = [];
        foreach ($res as $row) {
            $hits_per_day[$row['day']] = $row['count'];
        }

        return $hits_per_day;
    }

    public function getTotalVisitsForUrl(int $url_id): int
    {

        $res = $this->sqlite->executeSingle(
            "SELECT count(*) as count FROM `visit_log` WHERE `url_id`=?;",
            [[$url_id, \SQLITE3_INTEGER]]
        );

        return $res[0]['count'] ?? 0;
    }

    public function getMostVisitedShortUrls(int $limit): array
    {
        $res = $this->sqlite->executeSingle(
            "SELECT `short_url`, count(*) as count FROM `visit_log` LEFT JOIN `urls` ON (`visit_log`.`url_id` = `urls`.`id`) GROUP BY `url_id` ORDER BY count DESC LIMIT ?;",
            [[$limit, \SQLITE3_INTEGER]]
        );

        $most_visited = [];
        foreach ($res as $row) {
            $most_visited[$row['short_url']] = $row['count'];
        }
        return $most_visited;
    }

    /**
     * This returns the top N urls by number of distinct short links
     * (not by number of attempts to shorten)
     */
    public function getMostShortenedUrls(int $limit): array
    {
        $res = $this->sqlite->executeSingle(
            "SELECT `long_url`, count(*) as count FROM `urls` GROUP BY `long_url` ORDER BY count DESC LIMIT ?;",
            [[$limit, \SQLITE3_INTEGER]]
        );

        $most_shortened = [];
        foreach ($res as $row) {
            $most_shortened[htmlspecialchars($row['long_url'])] = $row['count'];
        }
        return $most_shortened;
    }
}
