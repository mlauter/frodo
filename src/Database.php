<?php declare(strict_types=1);

namespace Frodo;

use Frodo\Database\SQLite;
use Frodo\Encoder;
use Frodo\Exception\DatabaseException;
use Frodo\Exception\NotFoundException;
use Frodo\Exception\InUseException;
use \Monolog\Logger;
use \Monolog\Registry;

class Database
{

    /**
     * Some notes on the db schema
     *
     * What is going on with the `is_autogen` nullable field?
     * Our url shorten has a few constraints.
     * 1) A given long url should always return the same generated short url
     * 2) Users should be able to create custom short urls
     * Given that I'm using the autoincrement id to produce short urls,
     * I cannot use the shorturl to dedupe.
     *
     * Simply doing a read to check for the long url, then writing
     * if not found would create a race condition. This is true
     * even if the read-write is done within a db transaction.
     * In order to guarantee uniqueness, I need a db constraint.
     * I can't just put the unique constraint on the long_url though
     * because this would preclude custom short urls.
     *
     * In sqlite (and mysql, but not all sql servers), nulls do not count
     * towards uniqueness constraints. I can therefore use an additional
     * field `is_autogen` as part of the unique index. `is_autogen` will be
     * 1 for autogenerated short urls, and null for custom.
     *
     * As a final note, in a production system, I would not index the full
     * long_url - it would be too slow and space inefficient.
     * Other dbs allow indexing a prefix of a long varchar field, or I
     * could store a hash of the long url and index that.
     */
    private const INIT_SQL = [
        "CREATE TABLE IF NOT EXISTS `urls` (
            `id` INTEGER PRIMARY KEY AUTOINCREMENT,
            `long_url` text NOT NULL,
            `short_url` text NOT NULL DEFAULT '',
            `hits` unsigned integer NOT NULL DEFAULT 0,
            `is_autogen` unsigned integer DEFAULT NULL,
            `create_date` unsigned integer NOT NULL
        );",
        'CREATE UNIQUE INDEX IF NOT EXISTS `short_url_idx` ON `urls`(`short_url`);',
        'CREATE UNIQUE INDEX IF NOT EXISTS `long_url_autogen_idx` ON `urls`(`long_url`, `is_autogen`);',
        'CREATE INDEX IF NOT EXISTS `hits_idx` ON `urls`(`hits`);',
    ];

    /** @var SQLite */
    private $sqlite;

    /** @var Encoder */
    private $encoder;

    /** @var Logger */
    private $logger;

    public function __construct(string $datafile, Encoder $encoder, Logger $logger = null)
    {
        $this->encoder = $encoder;
        $this->sqlite  = new SQLite($datafile);

        // Initialize the database
        $this->sqlite->runInTransaction(
            [$this->sqlite, 'executeMultiNoParams'],
            [self::INIT_SQL]
        );

        if (is_null($logger)) {
            $logger = Registry::logger();
        }
        $this->logger = $logger;
    }

    /** @throws \Exception */
    public function findOrCreateAutoShortUrl(string $long_url): string
    {

        try {
            $short_url = $this->sqlite->runInTransaction(
                function (string $long_url): string {
                    // Attempt to store new url record
                    $this->sqlite->executeSingle(
                        "INSERT INTO `urls` (`long_url`, `is_autogen`, `create_date`) VALUES (?, 1, strftime('%s', 'now'));",
                        [[$long_url, \SQLITE3_TEXT]]
                    );

                    // Get the last autogenerated id on this connection
                    $row_id = $this->sqlite->lastInsertRowID();

                    // Store encoded short_url
                    // Choosing to do some extra work on the write side
                    // to make the read code simpler
                    // assuming a url shortener will be
                    // a read-heavy application
                    $short_url = $this->encoder->encode($row_id);
                    $this->sqlite->executeSingle(
                        "UPDATE `urls` SET `short_url`=? WHERE `id`=?;",
                        [
                            [$short_url, \SQLITE3_TEXT],
                            [$row_id, \SQLITE3_INTEGER],
                        ]
                    );

                    return $short_url;
                },
                [$long_url]
            );
            '@phan-var string $short_url';
        } catch (DatabaseException $e) {
            // duplicate key exception:
            // lookup the existing short_url
            if ($e->getDbErrorCode() === SQLite::SQLITE_CONSTRAINT) {
                $res = $this->sqlite->executeSingle(
                    "SELECT `short_url` FROM `urls` WHERE `long_url`=? AND `is_autogen`=1;",
                    [[$long_url, \SQLITE3_TEXT]]
                );
                $short_url = $res[0]['short_url'] ?? null;
                if (is_null($short_url)) {
                    $this->logger->error("Unexpected exception retrieving short url for long url {$long_url} after duplicate key exception");
                    throw new \RuntimeException("Unexpected exception retrieving short url");
                }
                return $short_url;
            }

            throw $e;
        }

        return $short_url;
    }

    public function createCustomShortUrl(string $long_url, string $short_url): string
    {
        try {
            $this->sqlite->executeSingle(
                "INSERT INTO `urls` (`long_url`, `short_url`, `create_date`) VALUES (?, ?, strftime('%s', 'now'));",
                [
                    [$long_url, \SQLITE3_TEXT],
                    [$short_url, \SQLITE3_TEXT],
                ]
            );
        } catch (DatabaseException $e) {
            if ($e->getDbErrorCode() === SQLite::SQLITE_CONSTRAINT) {
                throw new InUseException();
            }
            throw $e;
        }

        return $short_url;
    }

    public function findByShortUrl(string $short_url): string
    {
        $res = $this->sqlite->executeSingle(
            "SELECT `id`, `long_url` FROM `urls` WHERE `short_url`=?",
            [[$short_url, \SQLITE3_TEXT]]
        );

        $long_url = $res[0]['long_url'] ?? null;
        if (is_null($long_url)) {
            throw new NotFoundException();
        }

        // could lose hit count by not running in transaction
        // but doesn't seem critical for hit count to be exactly
        // accurate. would be much better to move this write
        // out of the read path and handle it async
        try {
            $this->sqlite->executeSingle(
                "UPDATE `urls` SET `hits`=`hits`+1 WHERE `id`=?",
                [[$res[0]['id'], \SQLITE3_INTEGER]]
            );
        } catch (\Exception $e) {
            // ignore
        }

        return $long_url;
    }
}
